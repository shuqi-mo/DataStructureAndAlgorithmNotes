# 串

## 字符串匹配：KMP

### 暴力匹配

$O(mn)$

文本串：aabaabaaf

模式串：aabaaf

- 每次发现不匹配了从头移动，比如发现b和f不匹配，接下来是让abaab和aabaaf匹配
- aabaab aaf与aabaaf匹配 - a abaaba af与aabaaf匹配

### KMP

$O(m+n)$

- 对于暴力匹配的例子，发现b和f不匹配后，接下来模式串跳到b的位置，从这个位置开始与文本串匹配
- aabaab aaf与aabaaf匹配 - aabaa baaf与aa baaf匹配
- 思想：b与f不匹配，此时前面的字符串是aabaa，b的前缀是aa后缀也是，所以后缀已经匹配上的aa下次匹配时一定可以匹配上前缀的aa，所以下一次移动子串时可以直接把开头位置移到后缀的aa，然后从冲突位置b重新开始匹配
- 核心：**怎么求一个字符串的最长相等前后缀？**
- KMP高效的原因：**文本串的指针不会回溯**

#### 前缀表

以aabaaf为例

- 前缀：包含首字母不包含尾字母的所有子串。a aa aab aaba aabaa
- 后缀：包含尾字母不包含首字母的所有子串。f af aaf baaf abaaf

aabaaf的前缀表：分别求a aa aab aaba aabaa aabaaf的最长相等前后缀

|  a   |  a   |  b   |  a   |  a   |  f   |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  1   |  0   |  1   |  2   |  0   |

- 冲突位置是f，此时要看回前面的一个字符a，前缀表中内容是2，代表这里有一个后缀aa，前面有一个与其相等的前缀aa，后面的aa在匹配时发生了冲突，我们要去找前面的那个aa，看它的后面能不能匹配上，这里的下标对应2**【从0开始的字符串，最长相等前后缀的长度等于要跳到的下标位置】**

#### next数组

- 发生冲突时，next数组告诉我们应该回退到哪里，不用去查前面一个元素了
- 右移一下，起始位置设为-1
- -1的含义：如果第一个字符就不匹配了，不需要去查子串指针应该跳到哪，而是应该让主串指针往后移一位

|  a   |  a   |  b   |  a   |  a   |  f   |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  1   |  0   |  1   |  2   |  0   |
|  -1  |  0   |  1   |  0   |  1   |  2   |

#### nextval数组

- 思想：拿一个相等的字符放到冲突位置没有意义，一定会继续失配

|  编号   |  0   |  1   |  2   |  3   |  4   |  5   |  6   |
| :-----: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|    S    |  a   |  b   |  a   |  b   |  a   |  a   |  a   |
|  next   |  -1  |  0   |  0   |  1   |  2   |  3   |  1   |
| nextval |  -1  |  0   |  -1  |  0   |  -1  |  3   |  1   |

编号0：原地不动，nextval=next

编号1：b - a，nextval=next

编号2：a - a，相同了，把nextval设为前面那个a的nextval值

编号3：b - b，相同了，把nextval设为前面那个b的nextval值

……

### KMP的代码实现

这里求的next数组是第一行的那个，不是第二行的

```c++
void getNext(vector<int>next, string S) {
    // 1.初始化：指针i指向后缀末尾位置，指针j指向前缀末尾位置，也是从i开始到前面的这个字符串的最长相等前后缀的长度
    int j = 0;
    next[0] = 0;
    for (int i = 1; i < S.size(); i++) {
    	// 2.处理前后缀不相同的情况：跳
        while (S[i] != S[j] && j > 0) {	// 不能写成if，因为是连续跳的过程
            j = next[j-1];
        }
    	// 3.处理前后缀相同的情况
        if (S[i] == S[j]) {
            j++;
        }
        // 4.更新next数组
        next[i] = j;
    }
}
```

## 补充资料

- KMP：b站上面代码随想录的视频